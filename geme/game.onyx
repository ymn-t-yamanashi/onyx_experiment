// https://onyxlang.io/docs/guides/raylib を参照
#load "./lib/packages"

use core {*}
use raylib

Player :: struct {
    x, y: f32;
    size: f32;
}

Checkpoint :: struct {
    x, y: f32;
    size: f32;
}

Mine :: struct {
    x, y: f32;
    size: f32;
}

//
// Game state
player: Player;
checkpoint: Checkpoint;
mines: [..] Mine;
score: i32;

resetGame :: () {
    // Reset the score.
    score = 0;

    // Put the player in the middle of the screen.
    player = .{
        x = 600,
        y = 450,
        size = 20
    };

    // Remove all existing mines
    array.clear(&mines);

    moveCheckpointAndSpawnMines();
}

moveCheckpointAndSpawnMines :: () {
    checkpoint = .{
        x = random.float(0, 1180),
        y = random.float(0, 880),
        size = 20,
    };

    // Spawn 5 mines at a time.
    // for 5 {
    //     mine := mineGenerator()
    //         |> iter.skip_while(m => collidesWithCheckpointOrPlayer(m))
    //         |> iter.next();

    //     array.push(&mines, mine);
    // }
}

collidesWithCheckpointOrPlayer :: (m: Mine) -> bool {
     return raylib.CheckCollisionCircleRec(
            .{ m.x, m.y }, m.size,
            .{ checkpoint.x, checkpoint.y, checkpoint.size, checkpoint.size }
        ) || raylib.CheckCollisionCircleRec(

            .{ m.x, m.y }, m.size,
            .{ player.x, player.y, player.size, player.size }
        );
}

// #doc "Produces an interator of random mines."
// mineGenerator :: () -> Iterator(Mine) {
//     return iter.generator(&.{}, _ => {
//         return Mine.{
//             x = random.float(0, 1180),
//             y = random.float(0, 880),
//             size = random.float(10, 30),
//         }, true;
//     });
// }
main :: () {
    random.set_seed(os.time());

    resetGame();

    // Create a new window
    raylib.InitWindow(1200, 900, "Raylib Example");

    // Limit FPS to 60
    raylib.SetTargetFPS(60);

    while !raylib.WindowShouldClose() {
        // Update player based on keys pressed
        dt := raylib.GetFrameTime();

        player_speed :: 160.0f;
        if raylib.IsKeyDown(.UP)    do player.y -= player_speed * dt;
        if raylib.IsKeyDown(.DOWN)  do player.y += player_speed * dt;
        if raylib.IsKeyDown(.LEFT)  do player.x -= player_speed * dt;
        if raylib.IsKeyDown(.RIGHT) do player.x += player_speed * dt;

        // Check for collision with the checkpoint
        if raylib.CheckCollisionCircleRec(
            .{ player.x, player.y }, player.size,
            .{ checkpoint.x, checkpoint.y, checkpoint.size, checkpoint.size }
        ) {
            score += 10;
            moveCheckpointAndSpawnMines();
        }

        // Check collision with mines
        for mine in mines {
            if raylib.CheckCollisionCircles(
                .{ player.x, player.y }, player.size,
                .{ mine.x, mine.y }, mine.size,
            ) {
                resetGame();
            }
        }

        // Start drawing
        raylib.BeginDrawing();
        
        // Clear the screen to a gray screen
        raylib.ClearBackground(.{20, 20, 20, 255});

        // Draw mines
        for mine in mines {
            raylib.DrawCircle(~~mine.x, ~~mine.y, mine.size, .{100, 0, 0, 255});
        }

        // Draw the checkpoint
        raylib.DrawRectangle(~~checkpoint.x, ~~checkpoint.y, ~~checkpoint.size, ~~checkpoint.size, .{50, 200, 0, 255});

        // Draw the player
        raylib.DrawCircle(~~player.x, ~~player.y, player.size, .{0, 0, 200, 255});

        // Draw the score
        raylib.DrawText(tprintf("Score: {}\0", score).data, 0, 0, 24, .{255, 255, 255, 255});

        // Finish drawing
        raylib.EndDrawing();
    }

    // Close window when done
    raylib.CloseWindow();
}
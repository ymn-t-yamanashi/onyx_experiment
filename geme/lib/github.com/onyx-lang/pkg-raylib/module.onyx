package raylib

PACKAGE_NAME :: "onyx_raylib"

use runtime
use core {cptr}
use cbindgen {*}

#if #defined(runtime.Generated_Foreign_Info) {
    foreign_block :: __foreign_block
} else {
    #library PACKAGE_NAME
}

LIGHTGRAY  :: Color.{ 200, 200, 200, 255 };   // Light Gray
GRAY       :: Color.{ 130, 130, 130, 255 };   // Gray
DARKGRAY   :: Color.{ 80, 80, 80, 255 };      // Dark Gray
YELLOW     :: Color.{ 253, 249, 0, 255 };     // Yellow
GOLD       :: Color.{ 255, 203, 0, 255 };     // Gold
ORANGE     :: Color.{ 255, 161, 0, 255 };     // Orange
PINK       :: Color.{ 255, 109, 194, 255 };   // Pink
RED        :: Color.{ 230, 41, 55, 255 };     // Red
MAROON     :: Color.{ 190, 33, 55, 255 };     // Maroon
GREEN      :: Color.{ 0, 228, 48, 255 };      // Green
LIME       :: Color.{ 0, 158, 47, 255 };      // Lime
DARKGREEN  :: Color.{ 0, 117, 44, 255 };      // Dark Green
SKYBLUE    :: Color.{ 102, 191, 255, 255 };   // Sky Blue
BLUE       :: Color.{ 0, 121, 241, 255 };     // Blue
DARKBLUE   :: Color.{ 0, 82, 172, 255 };      // Dark Blue
PURPLE     :: Color.{ 200, 122, 255, 255 };   // Purple
VIOLET     :: Color.{ 135, 60, 190, 255 };    // Violet
DARKPURPLE :: Color.{ 112, 31, 126, 255 };    // Dark Purple
BEIGE      :: Color.{ 211, 176, 131, 255 };   // Beige
BROWN      :: Color.{ 127, 106, 79, 255 };    // Brown
DARKBROWN  :: Color.{ 76, 63, 47, 255 };      // Dark Brown
WHITE      :: Color.{ 255, 255, 255, 255 };   // White
BLACK      :: Color.{ 0, 0, 0, 255 };         // Black
BLANK      :: Color.{ 0, 0, 0, 0 };           // Blank (Transparent)
MAGENTA    :: Color.{ 255, 0, 255, 255 };     // Magenta
RAYWHITE   :: Color.{ 245, 245, 245, 255 };   // My own White (raylib logo)

#local
__foreign_block :: #foreign PACKAGE_NAME {
    InitWindow :: (width, height: i32, title: cstr) -> void ---
    CloseWindow :: () -> void ---
    WindowShouldClose :: () -> bool ---
    IsWindowReady :: () -> bool ---
    IsWindowFullscreen :: () -> bool ---
    IsWindowHidden :: () -> bool ---
    IsWindowMinimized :: () -> bool ---
    IsWindowMaximized :: () -> bool ---
    IsWindowFocused :: () -> bool ---
    IsWindowResized :: () -> bool ---
    IsWindowState :: (flags: ConfigFlags) -> bool ---
    SetWindowState :: (flags: ConfigFlags) -> void ---
    ClearWindowState :: (flags: ConfigFlags) -> void ---
    ToggleFullscreen :: () -> void ---
    ToggleBorderlessWindowed :: () -> void ---
    MaximizeWindow :: () -> void ---
    MinimizeWindow :: () -> void ---
    RestoreWindow :: () -> void ---
    SetWindowIcon :: (image: Image) -> void ---
    SetWindowIcons :: (images: [] Image) -> void ---
    SetWindowTitle :: (title: cptr(u8)) -> void ---
    SetWindowPosition :: (x, y: i32) -> void ---
    SetWindowMonitor :: (monitor: i32) -> void ---
    SetWindowMinSize :: (width, height: i32) -> void ---
    SetWindowMaxSize :: (width, height: i32) -> void ---
    SetWindowSize :: (width, height: i32) -> void ---
    SetWindowOpacity :: (opacity: f32) -> void ---
    SetWindowFocused :: () -> void ---
    GetWindowHandle :: () -> cptr(void) ---
    GetScreenWidth :: () -> i32 ---
    GetScreenHeight :: () -> i32 ---
    GetRenderWidth :: () -> i32 ---
    GetRenderHeight :: () -> i32 ---
    GetMonitorCount :: () -> i32 ---
    GetCurrentMonitor :: () -> i32 ---
    @last_arg_is_return_value
    GetMonitorPosition :: (monitor: i32, out: &Vector2) -> void ---
    GetMonitorWidth :: (monitor: i32) -> i32 ---
    GetMonitorHeight :: (monitor: i32) -> i32 ---
    GetMonitorPhysicalWidth :: (monitor: i32) -> i32 ---
    GetMonitorPhysicalHeight :: (monitor: i32) -> i32 ---

    @last_arg_is_return_value
    GetWindowPosition :: (out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetWindowScaleDPI :: (out: &Vector2) -> void ---

    GetMonitorName :: (monitor: i32) -> cptr(u8) ---
    SetClipboardText :: (text: cptr(u8)) -> void ---
    GetClipboardText :: () -> cptr(u8) ---
    EnableEventWaiting :: () -> void ---
    DisableEventWaiting :: () -> void ---

    ShowCursor :: () -> void ---
    HideCursor :: () -> void ---
    IsCursorHidden :: () -> bool ---
    EnableCursor :: () -> void ---
    DisableCursor :: () -> void ---
    IsCursorOnScreen :: () -> bool ---

    ClearBackground :: (color: Color) -> void ---
    BeginDrawing :: () -> void ---
    EndDrawing :: () -> void ---
    BeginMode2D :: (camera: Camera2D) -> void ---
    EndMode2D :: () -> void ---
    BeginTextureMode :: (target: RenderTexture2D) -> void ---
    EndTextureMode :: () -> void ---
    BeginShaderMode :: (shader: Shader) -> void ---
    EndShaderMode :: () -> void ---
    BeginBlendMode :: (mode: BlendMode) -> void ---
    EndBlendMode :: () -> void ---
    BeginScissorMode :: (x, y, w, h: i32) -> void ---
    EndScissorMode :: () -> void ---
    BeginVrStereoMode :: (config: VrStereoConfig) -> void ---
    EndVrStereoMode :: () -> void ---

    @last_arg_is_return_value
    LoadVrStereoConfig :: (device: VrDeviceInfo, out: &VrStereoConfig) -> void ---
    UnloadVrStereoConfig :: (config: VrStereoConfig) -> void ---

    @last_arg_is_return_value
    LoadShader :: (vsFileName: cstr, fsFileName: cstr, out: &Shader) -> void ---
    @last_arg_is_return_value
    LoadShaderFromMemory :: (vsCode: cstr, fsCode: cstr, out: &Shader) -> void ---
    IsShaderReady :: (shader: Shader) -> bool ---
    GetShaderLocation :: (shader: Shader, uniformName: cstr) -> i32 ---
    GetShaderLocationAttrib :: (shader: Shader, attribName: cstr) -> i32 ---
    SetShaderValue :: (shader: Shader, locIndex: i32, value: rawptr, uniformType: ShaderUniformDataType) -> void ---
    SetShaderValueV :: (shader: Shader, locIndex: i32, value: rawptr, uniformType: ShaderUniformDataType, count: i32) -> void ---
    SetShaderValueMatrix :: (shader: Shader, locIndex: i32, mat: Matrix) -> void ---
    SetShaderValueTexture :: (shader: Shader, locIndex: i32, texture: Texture2D) -> void ---
    UnloadShader :: (shader: Shader) -> void ---

    @last_arg_is_return_value
    GetMouseRay :: (mousePosition: Vector2, camera: Camera, out: &Ray) -> void ---
    @last_arg_is_return_value
    GetCameraMatrix :: (camera: Camera, out: &Matrix) -> void ---
    @last_arg_is_return_value
    GetCameraMatrix2D :: (camera: Camera2D, out: &Matrix) -> void ---
    @last_arg_is_return_value
    GetWorldToScreen :: (position: Vector3, camera: Camera, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetScreenToWorld2D :: (position: Vector2, camera: Camera2D, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetWorldToScreenEx :: (position: Vector3, camera: Camera, width, height: i32, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetWorldToScreen2D :: (position: Vector2, camera: Camera2D, out: &Vector2) -> void ---

    SetTargetFPS :: (fps: i32) -> void ---
    GetFrameTime :: () -> f32 ---
    GetTime :: () -> f64 ---
    GetFPS :: () -> i32 ---

    SwapScreenBuffer :: () -> void ---
    PollInputEvents :: () -> void ---
    WaitTime :: (seconds: f64) -> void ---

    SetRandomSeed :: (seed: i32) -> void ---
    GetRandomValue :: (min, max: i32) -> i32 ---
    LoadRandomSequence :: (count: u32, min, max: i32) -> cptr(i32) ---
    UnloadRandomSequence :: (sequence: cptr(i32)) -> void ---

    // Varargs are a no go from Onyx land.
    // TraceLog(loglevel, text, ...)
    SetTraceLogLevel :: (logLevel: TraceLogLevel) -> void ---
    MemAlloc :: (size: u32) -> cptr(void) ---
    MemRealloc :: (ptr: cptr(void), size: u32) -> cptr(void) ---
    MemFree :: (ptr: cptr(void)) -> void ---

    LoadFileData :: (filename: cstr, dataSize: &i32) -> cptr(u8) ---
    UnloadFileData :: (data: cptr(u8)) -> void ---
    SaveFileData :: (filename: cstr, data: [] u8) -> void ---
    ExportDataAsCode :: (data: [] u8, filename: cstr) -> void ---
    LoadFileText :: (filename: cstr) -> cptr(u8) ---
    UnloadFileText :: (text: cptr(u8)) -> void ---
    SaveFileText :: (fileName: cstr, text: cstr) -> void ---

    FileExists :: (filename: cstr) -> bool ---
    DirectoryExists :: (dirpath: cstr) -> bool ---
    IsFileExtension :: (filename: cstr, ext: cstr) -> bool ---
    GetFileLength :: (filename: cstr) -> i32 ---
    GetFileExtension :: (filename: cstr) -> cptr(u8) ---
    GetFileName :: (filename: cstr) -> cptr(u8) ---
    GetFileNameWithoutExt :: (filepath: cstr) -> cptr(u8) ---
    GetDirectoryPath :: (filepath: cstr) -> cptr(u8) ---
    GetPrevDirectoryPath :: (dirpath: cstr) -> cptr(u8) ---
    GetWorkingDirectory :: () -> cptr(u8) ---
    GetApplicationDirectory :: () -> cptr(u8) ---
    ChangeDirectory :: (dir: cstr) -> bool ---
    IsPathFile :: (path: cstr) -> bool ---
    @last_arg_is_return_value
    LoadDirectoryFiles :: (dirpath: cstr, out: &FilePathList) -> void ---
    @last_arg_is_return_value
    LoadDirectoryFilesEx :: (basepath: cstr, filter: cstr, scanSubdirs: bool, out: &FilePathList) -> void ---
    UnloadDirectoryFiles :: (files: FilePathList) -> void ---
    IsFileDropped :: () -> bool ---
    @last_arg_is_return_value
    LoadDroppedFiles :: (out: &FilePathList) -> void ---
    UnloadDroppedFiles :: (files: FilePathList) -> void ---
    GetFileModTime :: (fileName: cstr) -> u64 ---

    CompressData :: (data: [] u8, compDataSize: &i32) -> cptr(u8) ---
    DecompressData :: (data: [] u8, dataSize: &i32) -> cptr(u8) ---
    EncodeDataBase64 :: (data: [] u8, outputSize: &i32) -> cptr(u8) ---
    DecodeDataBase64 :: (data: [] u8) -> cptr(u8) ---

    @last_arg_is_return_value
    LoadAutomationEventList :: (filename: cstr, out: &AutomationEventList) -> void ---
    UnloadAutomationEventList :: (list: &AutomationEventList) -> void ---
    ExportAutomationEventList :: (list: AutomationEventList, filename: cstr) -> void ---
    SetAutomationEventList :: (list: &AutomationEventList) -> void ---
    SetAutomationEventBaseFrame :: (frame: i32) -> void ---
    StartAutomationEventRecording :: () -> void ---
    StopAutomationEventRecording :: () -> void ---
    PlayAutomationEvent :: (event: AutomationEvent) -> void ---

    IsKeyPressed :: (key: KeyboardKey) -> bool ---
    IsKeyPressedRepeat :: (key: KeyboardKey) -> bool ---
    IsKeyDown :: (key: KeyboardKey) -> bool ---
    IsKeyReleased :: (key: KeyboardKey) -> bool ---
    IsKeyUp :: (key: KeyboardKey) -> bool ---
    GetKeyPressed :: () -> KeyboardKey ---
    GetCharPressed :: () -> i32 ---
    SetExitKey :: (key: KeyboardKey) -> void ---

    IsGamepadAvailable :: (gamepad: i32) -> bool ---
    GetGamepadName :: (gamepad: i32) -> cptr(u8) ---
    IsGamepadButtonPressed :: (gamepad: i32, button: GamepadButton) -> bool ---
    IsGamepadButtonDown :: (gamepad: i32, button: GamepadButton) -> bool ---
    IsGamepadButtonReleased :: (gamepad: i32, button: GamepadButton) -> bool ---
    IsGamepadButtonUp :: (gamepad: i32, button: GamepadButton) -> bool ---
    GetGamepadButtonPressed :: () -> GamepadButton ---
    GetGamepadAxisCount :: (gamepad: i32) -> i32 ---
    GetGamepadAxisMovement :: (gamepad: i32, axis: GamepadAxis) -> f32 ---
    SetGamepadMappings :: (mappings: cstr) -> i32 ---

    IsMouseButtonPressed :: (button: MouseButton) -> bool ---
    IsMouseButtonDown :: (button: MouseButton) -> bool ---
    IsMouseButtonReleased :: (button: MouseButton) -> bool ---
    IsMouseButtonUp :: (button: MouseButton) -> bool ---
    GetMouseX :: () -> i32 ---
    GetMouseY :: () -> i32 ---
    @last_arg_is_return_value @link_name.{"GetMousePosition"}
    GetMousePosition_ :: (out: &Vector2) -> void ---
    @last_arg_is_return_value @link_name.{"GetMouseDelta"}
    GetMouseDelta_ :: (out: &Vector2) -> void ---
    SetMousePosition :: (x, y: i32) -> void ---
    SetMouseOffset :: (offsetX, offsetY: i32) -> void ---
    SetMouseScale :: (scaleX, scaleY: f32) -> void ---
    GetMouseWheelMove :: () -> f32 ---
    @last_arg_is_return_value
    GetMouseWheelMoveV :: (out: &Vector2) -> void ---
    SetMouseCursor :: (cursor: i32) -> void ---

    GetTouchX :: () -> i32 ---
    GetTouchY :: () -> i32 ---
    @last_arg_is_return_value
    GetTouchPosition :: (index: i32, out: &Vector2) -> void ---
    GetTouchPointId :: (index: i32) -> i32 ---
    GetTouchPointCount :: () -> i32 ---

    SetGesturesEnabled :: (flags: u32) -> void ---
    IsGestureDetected :: (gesture: Gesture) -> bool ---
    GetGestureDetected :: () -> Gesture ---
    GetGestureHoldDuration :: () -> f32 ---
    @last_arg_is_return_value
    GetGestureDragVector :: (out: &Vector2) -> void ---
    GetGestureDragAngle :: () -> f32 ---
    @last_arg_is_return_value
    GetGesturePinchVector :: (out: &Vector2) -> void ---
    GetGesturePinchAngle :: () -> f32 ---

    UpdateCamera :: (camera: &Camera, mode: CameraMode) -> void ---
    UpdateCameraPro :: (camera: &Camera, movement: Vector3, rotation: Vector3, zoom: f32) -> void ---

    SetShapesTexture :: (texture: Texture2D, source: Rectangle) -> void ---

    DrawPixel :: (posX, posY: i32, color: Color) -> void ---
    DrawPixelV :: (pos: Vector2, color: Color) -> void ---
    DrawLine :: (startX, startY, endX, endY: i32, color: Color) -> void ---
    DrawLineV :: (start, end: Vector2, color: Color) -> void ---
    DrawLineEx :: (start, end: Vector2, thick: f32, color: Color) -> void ---
    DrawLineStrip :: (points: [] Vector2, color: Color) -> void ---
    DrawLineBezier :: (start, end: Vector2, think: f32, color: Color) -> void ---
    DrawCircle :: (centerX, centerY: i32, radius: f32, color: Color) -> void ---
    DrawCircleSector :: (center: Vector2, radius: f32, startAngle, endAngle: f32, segments: i32, color: Color) -> void ---
    DrawCircleSectorLines :: (center: Vector2, radius: f32, startAngle, endAngle: f32, segments: i32, color: Color) -> void ---
    DrawCircleV :: (center: Vector2, radius: f32, color: Color) -> void ---
    DrawCircleLines :: (centerX, centerY: i32, radius: f32, color: Color) -> void ---
    DrawCircleLinesV :: (centeR: Vector2, radius: f32, color: Color) -> void ---
    DrawEllipse :: (centerX, centerY: i32, radiusH, radiusV: f32, color: Color) -> void ---
    DrawEllipseLines :: (centerX, centerY: i32, radiusH, radiusV: f32, color: Color) -> void ---
    DrawRing :: (center: Vector2, innerRadius, outerRadius, startAngle, endAngle: f32, segments: i32, color: Color) -> void ---
    DrawRingLines :: (center: Vector2, innerRadius, outerRadius, startAngle, endAngle: f32, segments: i32, color: Color) -> void ---
    DrawRectangle :: (posX, posY, width, height: i32, color: Color) -> void ---
    DrawRectangleV :: (position, size: Vector2, color: Color) -> void ---
    DrawRectangleRec :: (rec: Rectangle, color: Color) -> void ---
    DrawRectanglePro :: (rec: Rectangle, origin: Vector2, rotation: f32, color: Color) -> void ---
    DrawRectangleGradientV :: (posX, posY, width, height: i32, color1, color2: Color) -> void ---
    DrawRectangleGradientH :: (posX, posY, width, height: i32, color1, color2: Color) -> void ---
    DrawRectangleLines :: (posX, posY, width, height: i32, color: Color) -> void ---
    DrawRectangleLinesEx :: (rec: Rectangle, lineThick: f32, color: Color) -> void ---
    DrawRectangleRounded :: (rec: Rectangle, roundness: f32, segments: i32, color: Color) -> void ---
    DrawRectangleRoundedLines :: (rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: Color) -> void ---
    DrawTriangle :: (v1, v2, v3: Vector2, color: Color) -> void ---
    DrawTriangleLines :: (v1, v2, v3: Vector2, color: Color) -> void ---
    DrawTriangleFan :: (points: [] Vector2, color: Color) -> void ---
    DrawTriangleStrip :: (points: [] Vector2, color: Color) -> void ---
    DrawPoly :: (center: Vector2, sides: i32, radius, rotation: f32, color: Color) -> void ---
    DrawPolyLines :: (center: Vector2, sides: i32, radius, rotation: f32, color: Color) -> void ---
    DrawPolyLinesEx :: (center: Vector2, sides: i32, radius, rotation: f32, lineThick: f32, color: Color) -> void ---

    @last_arg_is_return_value
    GetSplinePointLinear :: (start, end: Vector2, t: f32, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetSplinePointBasis :: (p1, p2, p3, p4: Vector2, t: f32, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetSplinePointCatmullRom :: (p1, p2, p3, p4: Vector2, t: f32, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetSplinePointBezierQuad :: (p1, p2, p3: Vector2, t: f32, out: &Vector2) -> void ---
    @last_arg_is_return_value
    GetSplinePointBezierCubic :: (p1, c2, c3, p4: Vector2, t: f32, out: &Vector2) -> void ---

    CheckCollisionRecs :: (rec1, rec2: Rectangle) -> bool ---
    CheckCollisionCircles :: (center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) -> bool ---
    CheckCollisionCircleRec :: (center: Vector2, radius: f32, rec: Rectangle) -> bool ---
    CheckCollisionPointRec :: (point: Vector2, rec: Rectangle) -> bool ---
    CheckCollisionPointCircle :: (point: Vector2, center: Vector2, radius: f32) -> bool ---
    CheckCollisionPointTriangle :: (pointer: Vector2, p1, p2, p3: Vector2) -> bool ---
    CheckCollisionPointPoly :: (point: Vector2, points: [] Vector2) -> bool ---
    CheckCollisionLines :: (start1, end1, start2, end2: Vector2, collision: &Vector2) -> bool ---
    CheckCollisionPointLine :: (point: Vector2, p1, p2: Vector2, threshold: i32) -> bool ---
    @last_arg_is_return_value
    GetCollisionRec :: (rec1, rec2: Rectangle, out: &Rectangle) -> void ---

    @last_arg_is_return_value
    LoadImage :: (filename: cstr, out: &Image) -> void ---
    @last_arg_is_return_value
    LoadImageRaw :: (filename: cstr, width, height, format, headerSize: i32, out: &Image) -> void ---
    @last_arg_is_return_value
    LoadImageSvg :: (filename_or_string: cstr, width, height: i32, out: &Image) -> void ---
    @last_arg_is_return_value
    LoadImageAnim :: (filename: cstr, frames: &i32, out: &Image) -> void ---
    @last_arg_is_return_value
    LoadImageFromMemory :: (filetype: cstr, data: [] u8, out: &Image) -> void ---
    @last_arg_is_return_value
    LoadImageFromTexture :: (texture: Texture2D, out: &Image) -> void ---
    @last_arg_is_return_value
    LoadImageFromScreen :: (out: &Image) -> void ---
    IsImageReady :: (image: Image) -> bool ---
    UnloadImage :: (image: Image) -> void ---
    ExportImage :: (image: Image, filename: cstr) -> bool ---
    ExportImageToMemory :: (image: Image, filetype: cstr, filesize: &i32) -> cptr(u8) ---
    ExportImageAsCode :: (image: Image, filename: cstr) -> bool ---

    @last_arg_is_return_value
    GenImageColor :: (width, height: i32, color: Color, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageGradientLinear :: (width, height: i32, direction: i32, start, end: Color, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageGradientRadial :: (width, height: i32, density: f32, inner, outer: Color, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageGradientSquare :: (width, height: i32, density: f32, inner, outer: Color, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageChecked :: (width, height, checksX, checksY: i32, col1, col2: Color, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageWhiteNoise :: (width, height: i32, factor: f32, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImagePerlinNoise :: (width, height: i32, offsetX, offsetY: i32, scale: f32, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageCellular :: (width, height: i32, tileSize: i32, out: &Image) -> void ---
    @last_arg_is_return_value
    GenImageText :: (width, height: i32, text: cstr, out: &Image) -> void ---

    @last_arg_is_return_value
    ImageCopy :: (image: Image, out: &Image) -> void ---
    @last_arg_is_return_value
    ImageFromImage :: (image: Image, rec: Rectangle, out: &Image) -> void ---
    @last_arg_is_return_value
    ImageText :: (text: cstr, fontSize: i32, color: Color, out: &Image) -> void ---
    @last_arg_is_return_value
    ImageTextEx :: (font: Font, text: cstr, fontSize: f32, spacing: f32, tint: Color, out: &Image) -> void ---
    ImageFormat :: (image: &Image, newFormat: i32) -> void ---
    ImageToPOT :: (image: &Image, fill: Color) -> void ---
    ImageCrop :: (image: &Image, crop: Rectangle) -> void ---
    ImageAlphaCrop :: (image: &Image, threshold: f32) -> void ---
    ImageAlphaClear :: (image: &Image, color: Color, threshold: f32) -> void ---
    ImageAlphaMask :: (image: &Image, alphaMask: Image) -> void ---
    ImageAlphaPremultiply :: (image: &Image) -> void ---
    ImageBlurGaussian :: (image: &Image, blurSize: i32) -> void ---
    // ImageKernelConvolution :: (image: &Image, kernel: [] f32) -> void ---   This is missing on Raylib 5.0 releases
    ImageResize :: (image: &Image, newWidth, newHeight: i32) -> void ---
    ImageResizeNN :: (image: &Image, newWidth, newHeight: i32) -> void ---
    ImageResizeCanvas :: (image: &Image, newWidth, newHeight, offsetX, offsetY: i32, fill: Color) -> void ---
    ImageMipmaps :: (image: &Image) -> void ---
    ImageDither :: (image: &Image, rBpp, gBpp, bBpp, aBpp: i32) -> void ---
    ImageFlipVertical :: (image: &Image) -> void ---
    ImageFlipHorizontal :: (image: &Image) -> void ---
    ImageRotate :: (image: &Image, degree: i32) -> void ---
    ImageRotateCW :: (image: &Image) -> void ---
    ImageRotateCCW :: (image: &Image) -> void ---
    ImageColorTint :: (image: &Image, color: Color) -> void ---
    ImageColorInvert :: (image: &Image) -> void ---
    ImageColorGrayscale :: (image: &Image) -> void ---
    ImageColorContrast :: (image: &Image, contrast: f32) -> void ---
    ImageColorBrightness :: (image: &Image, brightness: i32) -> void ---
    ImageColorReplace :: (Image: &Image, color, replace: Color) -> void ---
    LoadImageColors :: (image: Image) -> cptr(Color) ---
    LoadImagePalette :: (image: Image, maxPaletteSize: i32, colorCount: &i32) -> cptr(Color) ---
    UnloadImageColors :: (colors: cptr(Color)) -> void ---
    UnloadImagePalette :: (colors: cptr(Color)) -> void ---
    @last_arg_is_return_value
    GetImageAlphaBorder :: (image: Image, threshold: f32, out: &Rectangle) -> void ---
    @last_arg_is_return_value
    GetImageColor :: (image: Image, x, y: i32, out: &Color) -> void ---

    ImageClearBackground :: (dst: &Image, color: Color) -> void ---
    ImageDrawPixel :: (dst: &Image, x, y: i32, color: Color) -> void ---
    ImageDrawPixelV :: (dst: &Image, pos: Vector2, color: Color) -> void ---
    ImageDrawLine :: (dst: &Image, startX, startY, endX, endY: i32, color: Color) -> void ---
    ImageDrawLineV :: (dst: &Image, start, end: Vector2, color: Color) -> void ---
    ImageDrawCircle :: (dst: &Image, centerX, centerY, radius: i32, color: Color) -> void ---
    ImageDrawCircleV :: (dst: &Image, center: Vector2, radius: i32, color: Color) -> void ---
    ImageDrawCircleLines :: (dst: &Image, centerX, centerY, radius: i32, color: Color) -> void ---
    ImageDrawCircleLinesV :: (dst: &Image, center: Vector2, radius: i32, color: Color) -> void ---
    ImageDrawRectangle :: (dst: &Image, posX, posY, with, height: i32, color: Color) -> void ---
    ImageDrawRectangleV :: (dst: &Image, pos, size: Vector2, color: Color) -> void ---
    ImageDrawRectangleRec :: (dst: &Image, rec: Rectangle, color: Color) -> void ---
    ImageDrawRectangleLines :: (dst: &Image, rec: Rectangle, thick: i32, color: Color) -> void ---
    ImageDraw :: (dst: &Image, src: Image, srcRec, dstRec: Rectangle, tint: Color) -> void ---
    ImageDrawText :: (dst: &Image, text: cstr, posX, posY, fontSize: i32, color: Color) -> void ---
    ImageDrawTextEx :: (dst: &Image, font: Font, text: cstr, pos: Vector2, fontSize, spacing: f32, tint: Color) -> void ---

    @last_arg_is_return_value
    LoadTexture :: (filename: cstr, out: &Texture2D) -> void ---
    @last_arg_is_return_value
    LoadTextureFromImage :: (image: Image, out: &Texture2D) -> void ---
    @last_arg_is_return_value
    LoadTextureCubemap :: (image: Image, layout: i32, out: &TextureCubemap) -> void ---
    @last_arg_is_return_value
    LoadRenderTexture :: (width, height: i32, out: &RenderTexture2D) -> void ---
    IsTextureReady :: (texture: Texture2D) -> bool ---
    UnloadTexture :: (texture: Texture2D) -> void ---
    IsRenderTextureReady :: (texture: RenderTexture2D) -> bool ---
    UnloadRenderTexture :: (rexture: RenderTexture2D) -> void ---
    UpdateTexture :: (texture: Texture2D, pixels: rawptr) -> void ---
    UpdateTextureRec :: (texture: Texture2D, rec: Rectangle, pixels: rawptr) -> void ---

    GenTextureMipmaps :: (texture: &Texture2D) -> void ---
    SetTextureFilter :: (texture: Texture2D, filter: TextureFilter) -> void ---
    SetTextureWrap :: (texture: Texture2D, wrap: TextureWrap) -> void ---

    DrawTexture :: (texture: Texture2D, posX, posY: i32, tint: Color) -> void ---
    DrawTextureV :: (texture: Texture2D, pos: Vector2, tint: Color) -> void ---
    DrawTextureEx :: (texture: Texture2D, pos: Vector2, rotation: f32, scale: f32, tint: Color) -> void ---
    DrawTextureRec :: (texture: Texture2D, source: Rectangle, pos: Vector2, tint: Color) -> void ---
    DrawTexturePro :: (texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) -> void ---
    DrawTextureNPatch :: (texture: Texture2D, patch: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) -> void ---

    @last_arg_is_return_value
    Fade :: (color: Color, alpha: f32, out: &Color) -> void ---
    ColorToInt :: (color: Color) -> u32 ---
    @last_arg_is_return_value
    ColorNormalize :: (color: Color, out: &Vector4) -> void ---
    @last_arg_is_return_value
    ColorFromNormalized :: (normalized: Vector4, out: &Color) -> void ---
    @last_arg_is_return_value
    ColorToHSV :: (color: Color, out: &Vector3) -> void ---
    @last_arg_is_return_value
    ColorFromHSV :: (hue, saturation, value: f32, out: &Color) -> void ---
    @last_arg_is_return_value
    ColorTint :: (color: Color, tint: Color, out: &Color) -> void ---
    @last_arg_is_return_value
    ColorBrightness :: (color: Color, factor: f32, out: &Color) -> void ---
    @last_arg_is_return_value
    ColorContrast :: (color: Color, contrast: f32, out: &Color) -> void ---
    @last_arg_is_return_value
    ColorAlpha :: (color: Color, alpha: f32, out: &Color) -> void ---
    @last_arg_is_return_value
    ColorAlphaBlend :: (dst, src, tint: Color, out: &Color) -> void ---
    @last_arg_is_return_value
    GetColor :: (hexValue: u32, out: &Color) -> void ---
    @last_arg_is_return_value
    GetPixelColor :: (srcPtr: rawptr, format: PixelFormat, out: &Color) -> void ---
    SetPixelColor :: (dstPtr: rawptr, color: Color, format: PixelFormat) -> void ---
    GetPixelDataSize :: (width, height: i32, format: PixelFormat) -> i32 ---

    @last_arg_is_return_value
    GetFontDefault :: (out: &Font) -> void ---
    @last_arg_is_return_value
    LoadFont :: (filename: cstr, out: &Font) -> void ---
    @last_arg_is_return_value
    LoadFontEx :: (filename: cstr, fontSize: i32, codepoints: [] i32, out: &Font) -> void ---
    @last_arg_is_return_value
    LoadFontFromImage :: (image: Image, key: Color, firstChar: i32, out: &Font) -> void ---
    @last_arg_is_return_value
    LoadFontFromMemory :: (fileType: cstr, data: [] u8, fontSize: i32, codepoints: [] i32, out: &Font) -> void ---
    IsFontReady :: (font: Font) -> void ---
    LoadFontData :: (filedata: [] u8, fontSize: i32, codepoints: [] i32, type: FontType) -> cptr(GlyphInfo) ---
    @last_arg_is_return_value
    GenImageFontAtlas :: (glyphs: cptr(GlyphInfo), rects: [] cptr(Rectangle), fontSize: i32, padding: i32, packMethod: i32, out: &Image) -> void ---
    UnloadFontData :: (glyphs: cptr(GlyphInfo), glyphCount: i32) -> void ---
    UnloadFont :: (font: Font) -> void ---
    ExportFontAsCode :: (font: Font, filename: cstr) -> bool ---

    DrawFPS :: (posX, posY: i32) -> void ---
    DrawText :: (text: cstr, posX, posY: i32, fontSize: i32, color: Color) -> void ---
    DrawTextEx :: (font: Font, text: cstr, pos: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void ---
    DrawTextPro :: (font: Font, text: cstr, position: Vector2, origin: Vector2, rotation, fontSize, spacing: f32, tint: Color) -> void ---
    DrawTextCodepoint :: (font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color) -> void ---
    DrawTextCodepoints :: (font: Font, codepoint: [] i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void ---

    SetTextLineSpacing :: (spacing: i32) -> void ---
    MeasureText :: (text: cstr, fontSize: i32) -> i32 ---
    @last_arg_is_return_value
    MeasureTextEx :: (font: Font, text: cstr, fontSize: f32, spacing: f32, out: &Vector2) -> void ---
    GetGlyphIndex :: (font: Font, codepoint: i32) -> i32 ---
    @last_arg_is_return_value
    GetGlyphInfo :: (font: Font, codepoint: i32, out: &GlyphInfo) -> void ---
    @last_arg_is_return_value
    GetGlyphAtlasRec :: (font: Font, codepoint: i32, out: &Rectangle) -> void ---

    //
    // NOTE: Intentionally ommitting these functions, as there
    // are better, more Onyx-centric version of these functions.
    //
    // // Text codepoints management functions (unicode characters)
    // RLAPI char *LoadUTF8(const int *codepoints, int length);                // Load UTF-8 text encoded from codepoints array
    // RLAPI void UnloadUTF8(char *text);                                      // Unload UTF-8 text encoded from codepoints array
    // RLAPI int *LoadCodepoints(const char *text, int *count);                // Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
    // RLAPI void UnloadCodepoints(int *codepoints);                           // Unload codepoints data from memory
    // RLAPI int GetCodepointCount(const char *text);                          // Get total number of codepoints in a UTF-8 encoded string
    // RLAPI int GetCodepoint(const char *text, int *codepointSize);           // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
    // RLAPI int GetCodepointNext(const char *text, int *codepointSize);       // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
    // RLAPI int GetCodepointPrevious(const char *text, int *codepointSize);   // Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
    // RLAPI const char *CodepointToUTF8(int codepoint, int *utf8Size);        // Encode one codepoint into UTF-8 byte array (array length returned as parameter)

    // // Text strings management functions (no UTF-8 strings, only byte chars)
    // // NOTE: Some strings allocate memory internally for returned strings, just be careful!
    // RLAPI int TextCopy(char *dst, const char *src);                                             // Copy one string to another, returns bytes copied
    // RLAPI bool TextIsEqual(const char *text1, const char *text2);                               // Check if two text string are equal
    // RLAPI unsigned int TextLength(const char *text);                                            // Get text length, checks for '\0' ending
    // RLAPI const char *TextFormat(const char *text, ...);                                        // Text formatting with variables (sprintf() style)
    // RLAPI const char *TextSubtext(const char *text, int position, int length);                  // Get a piece of a text string
    // RLAPI char *TextReplace(char *text, const char *replace, const char *by);                   // Replace text string (WARNING: memory must be freed!)
    // RLAPI char *TextInsert(const char *text, const char *insert, int position);                 // Insert text in a position (WARNING: memory must be freed!)
    // RLAPI const char *TextJoin(const char **textList, int count, const char *delimiter);        // Join text strings with delimiter
    // RLAPI const char **TextSplit(const char *text, char delimiter, int *count);                 // Split text into multiple strings
    // RLAPI void TextAppend(char *text, const char *append, int *position);                       // Append text at specific position and move cursor!
    // RLAPI int TextFindIndex(const char *text, const char *find);                                // Find first text occurrence within a string
    // RLAPI const char *TextToUpper(const char *text);                      // Get upper case version of provided string
    // RLAPI const char *TextToLower(const char *text);                      // Get lower case version of provided string
    // RLAPI const char *TextToPascal(const char *text);                     // Get Pascal case notation version of provided string
    // RLAPI int TextToInteger(const char *text);                            // Get integer value from text (negative values not supported)

    DrawLine3D :: (start, end: Vector3, color: Color) -> void ---
    DrawPoint3D :: (position: Vector3, color: Color) -> void ---
    DrawCircle3D :: (center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color) -> void ---
    DrawTriangle3D :: (v1: Vector3, v2: Vector3, v3: Vector3, color: Color) -> void ---
    DrawTriangleStrip3D :: (points: [] Vector3, color: Color) -> void ---
    DrawCube :: (position: Vector3, width: f32, height: f32, length: f32, color: Color) -> void ---
    DrawCubeV :: (position: Vector3, size: Vector3, color: Color) -> void ---
    DrawCubeWires :: (position: Vector3, width: f32, height: f32, length: f32, color: Color) -> void ---
    DrawCubeWiresV :: (position: Vector3, size: Vector3, color: Color) -> void ---
    DrawSphere :: (centerPos: Vector3, radius: f32, color: Color) -> void ---
    DrawSphereEx :: (centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color) -> void ---
    DrawSphereWires :: (centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color) -> void ---
    DrawCylinder :: (position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color) -> void ---
    DrawCylinderEx :: (startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color) -> void ---
    DrawCylinderWires :: (position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color) -> void ---
    DrawCylinderWiresEx :: (startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color) -> void ---
    DrawCapsule :: (startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color) -> void ---
    DrawCapsuleWires :: (startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color) -> void  ---
    DrawPlane :: (centerPos: Vector3, size: Vector2, color: Color) -> void ---
    DrawRay :: (ray: Ray, color: Color) -> void ---
    DrawGrid :: (slices: i32, spacing: f32) -> void ---

    @last_arg_is_return_value
    LoadModel :: (filename: cstr, out: &Model) -> void ---
    @last_arg_is_return_value
    LoadModelFromMesh :: (mesh: Mesh, out: &Model) -> void ---
    IsModelReady :: (model: Model) -> bool ---
    UnloadModel :: (model: Model) -> void ---
    @last_arg_is_return_value
    GetModelBoundingBox :: (model: Model, out: &BoundingBox) -> void ---

    DrawModel :: (model: Model, position: Vector3, scale: f32, tint: Color) -> void ---
    DrawModelEx :: (model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void ---
    DrawModelWires :: (model: Model, position: Vector3, scale: f32, tint: Color) -> void ---
    DrawModelWiresEx :: (model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void ---
    DrawBoundingBox :: (box: BoundingBox, color: Color) -> void ---
    DrawBillboard :: (camera: Camera, texture: Texture2D, position: Vector3, size: f32, tint: Color) -> void ---
    DrawBillboardRec :: (camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> void ---
    DrawBillboardPro :: (camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color) -> void ---

    UploadMesh :: (mesh: &Mesh, dynamic: bool) -> void ---
    UpdateMeshBuffer :: (mesh: Mesh, index: i32, data: [] u8, offset: i32) -> void ---
    UnloadMesh :: (mesh: Mesh) -> void ---
    DrawMesh :: (mesh: Mesh, material: Material, transform: Matrix) -> void ---
    DrawMeshInstanced :: (mesh: Mesh, material: Material, transforms: &Matrix, instances: i32) -> void ---
    ExportMesh :: (mesh: Mesh, filename: cstr) -> bool ---
    @last_arg_is_return_value
    GetMeshBoundingBox :: (mesh: Mesh, out: &BoundingBox) -> void ---
    GenMeshTangents :: (mesh: &Mesh) -> void ---

    @last_arg_is_return_value
    GenMeshPoly :: (sides: i32, radius: f32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshPlane :: (width, length: f32, resX, resZ: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshCube :: (width, height, length: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshSphere :: (radius: f32, rings: i32, slices: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshHemiSphere :: (radius: f32, rings: i32, slices: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshCylinder :: (radius, height: f32, slices: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshCone :: (radius, height: f32, slices: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshTorus :: (radius, size: f32, radSeg, sides: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshKnot :: (radius, size: f32, radSeg, sides: i32, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshHeightmap :: (heightmap: Image, size: Vector3, out: &Mesh) -> void ---
    @last_arg_is_return_value
    GenMeshCubicmap :: (cubicmap: Image, cubeSize: Vector3, out: &Mesh) -> void ---

    LoadMaterials :: (filename: cstr, materialCount: &i32) -> cptr(Material) ---
    @last_arg_is_return_value
    LoadMaterialDefault :: (out: &Material) -> void ---
    IsMaterialReady :: (material: Material) -> bool ---
    UnloadMaterial :: (material: Material) -> void ---
    SetMaterialTexture :: (material: &Material, mapType: MaterialMapIndex, texture: Texture2D) -> void ---
    SetModelMeshMaterial :: (model: &Model, meshId: i32, materialId: i32) -> void ---

    LoadModelAnimations :: (filename: cstr, animCount: &i32) -> cptr(ModelAnimation) ---
    UpdateModelAnimation :: (model: Model, anim: ModelAnimation, frame: i32) -> void ---
    UnloadModelAnimation :: (anim: ModelAnimation) -> void ---
    UnloadModelAnimations :: (animations: cptr(ModelAnimation), animCount: i32) -> void ---
    IsModelAnimationValid :: (model: Model, anim: ModelAnimation) -> bool ---

    CheckCollisionSpheres :: (center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) -> bool ---
    CheckCollisionBoxes :: (box1, box2: BoundingBox) -> bool ---
    CheckCollisionBoxSphere :: (box: BoundingBox, center: Vector3, radius: f32) -> bool ---
    @last_arg_is_return_value
    GetRayCollisionSphere :: (ray: Ray, center: Vector3, radius: f32, out: &RayCollision) -> void ---
    @last_arg_is_return_value
    GetRayCollisionBox :: (ray: Ray, box: BoundingBox, out: &RayCollision) -> void ---
    @last_arg_is_return_value
    GetRayCollisionMesh :: (ray: Ray, mesh: Mesh, transform: Matrix, out: &RayCollision) -> void ---
    @last_arg_is_return_value
    GetRayCollisionTriangle :: (ray: Ray, p1, p2, p3: Vector3, out: &RayCollision) -> void ---
    @last_arg_is_return_value
    GetRayCollisionQuad :: (ray: Ray, p1, p2, p3, p4: Vector3, out: &RayCollision) -> void ---

    InitAudioDevice :: () -> void ---
    CloseAudioDevice :: () -> void ---
    IsAudioDeviceReady :: () -> void ---
    SetMasterVolume :: (volume: f32) -> void ---
    GetMasterVolume :: () -> f32 ---

    @last_arg_is_return_value
    LoadWave :: (filename: cstr, out: &Wave) -> void ---
    @last_arg_is_return_value
    LoadWaveFromMemory :: (fileType: cstr, data: [] u8, out: &Wave) -> void ---;
    IsWaveReady :: (wave: Wave) -> bool ---
    @last_arg_is_return_value
    LoadSound :: (filename: cstr, out: &Sound) -> void ---
    @last_arg_is_return_value
    LoadSoundFromWave :: (wave: Wave, out: &Sound) -> void ---
    @last_arg_is_return_value
    LoadSoundAlias :: (sound: Sound, out: &Sound) -> void ---
    IsSoundReady :: (sound: Sound) -> bool ---
    UpdateSound :: (sound: Sound, data: rawptr, sampleCount: i32) -> void ---
    UnloadWave :: (wave: Wave) -> void ---
    UnloadSound :: (sound: Sound) -> void ---
    UnloadSoundAlias :: (sound: Sound) -> void ---
    ExportWave :: (wave: Wave, filename: cstr) -> bool ---
    ExportWaveAsCode :: (wave: Wave, filename: cstr) -> bool ---

    PlaySound :: (sound: Sound) -> void ---
    StopSound :: (sound: Sound) -> void ---
    PauseSound :: (sound: Sound) -> void ---
    ResumeSound :: (sound: Sound) -> void ---
    IsSoundPlaying :: (sound: Sound) -> bool ---
    SetSoundVolume :: (sound: Sound, volume: f32) -> void ---
    SetSoundPitch :: (sound: Sound, pitch: f32) -> void ---
    SetSoundPan :: (sound: Sound, pan: f32) -> void ---
    @last_arg_is_return_value
    WaveCopy :: (wave: Wave, out: &Wave) -> void ---
    WaveCrop :: (wave: &Wave, initSample, finalSample: i32) -> void ---
    WaveFormat :: (wave: &Wave, sampleRate, sampleSize, channels: i32) -> void ---
    LoadWaveSamples :: (wave: Wave) -> cptr(f32) ---
    UnloadWaveSamples :: (samples: cptr(f32)) -> void ---

    @last_arg_is_return_value
    LoadMusicStream :: (filename: cstr, out: &Music) -> void ---
    @last_arg_is_return_value
    LoadMusicStreamFromMemory :: (filetype: cstr, data: [] u8, out: &Music) -> void ---
    IsMusicReady :: (music: Music) -> bool ---
    UnloadMusicStream :: (music: Music) -> void ---
    PlayMusicStream :: (msuic: Music) -> void ---
    IsMusicStreamPlaying :: (music: Music) -> bool ---
    UpdateMusicStream :: (music: Music) -> void ---
    StopMusicStream :: (music: Music) -> void ---
    PauseMusicStream :: (music: Music) -> void ---
    ResumeMusicStream :: (music: Music) -> void ---
    SeekMusicStream :: (music: Music, position: f32) -> void ---
    SetMusicVolume :: (music: Music, volume: f32) -> void ---
    SetMusicPitch :: (music: Music, pitch: f32) -> void ---
    SetMusicPan :: (music: Music, pan: f32) -> void ---
    GetMusicTimeLength :: (music: Music) -> f32 ---
    GetMusicTimePlayed :: (music: Music) -> f32 ---

    @last_arg_is_return_value
    LoadAudioStream :: (sampleRate, sampleSize, channels: u32, out: &AudioStream) -> void ---
    IsAudioStreamReady :: (stream: AudioStream) -> bool ---
    UnloadAudioStream :: (stream: AudioStream) -> void ---
    UpdateAudioStream :: (stream: AudioStream, data: rawptr, frameCount: i32) -> void ---
    IsAudioStreamProcessed :: (stream: AudioStream) -> bool ---
    PlayAudioStream :: (stream: AudioStream) -> void ---
    PauseAudioStream :: (stream: AudioStream) -> void ---
    ResumeAudioStream :: (stream: AudioStream) -> void ---
    IsAudioStreamPlaying :: (stream: AudioStream) -> bool ---
    StopAudioStream :: (stream: AudioStream) -> void ---
    SetAudioStreamVolume :: (stream: AudioStream, volume: f32) -> void ---
    SetAudioStreamPitch :: (stream: AudioStream, pitch: f32) -> void ---
    SetAudioStreamPan :: (stream: AudioStream, pan: f32) -> void ---
    SetAudioStreamBufferSizeDefault :: (size: i32) -> void ---
}

GetMousePosition :: #match {
    GetMousePosition_,
    () -> Vector2 {
        r: Vector2;
        GetMousePosition_(&r);
        return r;
    }
}

GetMouseDelta :: #match {
    GetMouseDelta_,
    () -> Vector2 {
        r: Vector2;
        GetMouseDelta_(&r);
        return r;
    }
}

Vector2 :: struct {
    x, y: f32;
}

Vector3 :: struct {
    x, y, z: f32;
}

Vector4 :: struct {
    x, y, z, w: f32;
}

Quaterion :: Vector4

Matrix :: struct {
    m0, m4, m8,  m12: f32;
    m1, m5, m9,  m13: f32;
    m2, m6, m10, m14: f32;
    m3, m7, m11, m15: f32;
}

Color :: struct {
    r, g, b, a: u8;
}

Rectangle :: struct {
    x, y, width, height: f32;
}

Image :: struct {
    data: cptr(void);
    width, height: i32;
    mipmaps, format: i32;
}

Texture :: struct {
    id: u32;
    width, height: i32;
    mipmaps, format: i32;
}

Texture2D :: Texture
TextureCubemap :: Texture

RenderTexture :: struct {
    id: u32;
    texture, depth: Texture;
}

RenderTexture2D :: RenderTexture

NPatchInfo :: struct {
    source: Rectangle;
    left, top, right, bottom: i32;
    layout: i32;
}

GlyphInfo :: struct {
    value: i32;
    offsetX, offseyY: i32;
    advanceX: i32;
    image: Image;
}

Font :: struct {
    baseSize: i32;
    glyphCount: i32;
    glyphPadding: i32;
    texture: Texture2D;
    recs: cptr(Rectangle);
    glyphs: cptr(GlyphInfo);
}

Camera3D :: struct {
    position: Vector3;
    target: Vector3;
    up: Vector3;
    fovy: f32;
    projection: i32;
}

Camera :: Camera3D

Camera2D :: struct {
    offset: Vector2;
    target: Vector2;
    rotation, zoom: f32;
}

Mesh :: struct {
    vertexCount: i32;
    triangleCount: i32;

    verticies: cptr(f32);
    texcorrds: cptr(f32);
    texcoords2: cptr(f32);
    normals: cptr(f32);
    tangets: cptr(f32);
    colors: cptr(u8);
    indicies: cptr(u16);

    animVerticies: cptr(f32);
    animNormals: cptr(f32);
    boneIds: cptr(u8);
    boneWeights: cptr(f32);

    vaoId: u32;
    vboId: cptr(u32);
}

Shader :: struct {
    id: u32;
    locs: cptr(i32);
}

MaterialMap :: struct {
    texture: Texture2D;
    color: Color;
    value: f32;
}

Material :: struct {
    shader: Shader;
    maps: cptr(MaterialMap);
    params: [4] f32;
}

Transform :: struct {
    translation: Vector3;
    rotation: Quaterion;
    scale: Vector3;
}

BoneInfo :: struct {
    name: [32] u8;
    parent: i32;
}

Model :: struct {
    transform: Matrix;
    meshCount: i32;
    materialCount: i32;
    meshes: cptr(Mesh);
    materials: cptr(Mesh);
    meshMaterial: cptr(i32);

    boneCount: i32;
    bones: cptr(BoneInfo);
    bindPose: cptr(Transform);
}

ModelAnimation :: struct {
    boneCount: i32;
    frameCount: i32;
    bones: cptr(BoneInfo);
    framePoses: cptr(Transform);
    name: [32] u8;
}

Ray :: struct {
    position: Vector3;
    direction: Vector3;
}

RayCollision :: struct {
    hit: bool;
    distance: f32;
    point: Vector3;
    normal: Vector3;
}

BoundingBox :: struct {
    min, max: Vector3;
}

Wave :: struct {
    frameCount, sampleRate, sampleSize, channels: u32;
    data: cptr(void);
}

rAudioBuffer :: struct {}
rAudioProcessor :: struct {}

AudioStream :: struct {
    buffer: cptr(rAudioBuffer);
    processor: cptr(rAudioProcessor);

    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
}

Sound :: struct {
    stream: AudioStream;
    frameCount: u32;
}

Music :: struct {
    stream: AudioStream;
    frameCount: u32;
    looping: bool;

    ctxType: i32;
    ctxData: cptr(void);
}

VrDeviceInfo :: struct {
    hResolution: i32;
    vResolution: i32;
    hScreenSize: f32;
    vScreenSize: f32;
    vScreenCenter: f32;
    eyeToScreenDistance: f32;
    lensSeparationDistance: f32;
    interpupillaryDistance: f32;
    lensDistoritionValues: [4] f32;
    chromaAbCorrection: [4] f32;
}

VrStereoConfig :: struct {
    projection: [2] Matrix;
    viewOffset: [2] Matrix;
    leftLensCenter: [2] f32;
    rightLensCenter: [2] f32;
    leftScreenCenter: [2] f32;
    rightScreenCenter: [2] f32;
    scale: [2] f32;
    scaleIn: [2] f32;
}

FilePathList :: struct {
    capacity, count: u32;
    paths: cptr(cptr(u8));
}

AutomationEvent :: struct {
    frame, type: u32;
    params: [4] i32;
}

AutomationEventList :: struct {
    capacity, count: u32;
    events: cptr(AutomationEvent);
}

ConfigFlags :: enum #flags {
    VSYNC_HINT         :: 0x00000040;   // Set to try enabling V-Sync on GPU
    FULLSCREEN_MODE    :: 0x00000002;   // Set to run program in fullscreen
    WINDOW_RESIZABLE   :: 0x00000004;   // Set to allow resizable window
    WINDOW_UNDECORATED :: 0x00000008;   // Set to disable window decoration (frame and buttons)
    WINDOW_HIDDEN      :: 0x00000080;   // Set to hide window
    WINDOW_MINIMIZED   :: 0x00000200;   // Set to minimize window (iconify)
    WINDOW_MAXIMIZED   :: 0x00000400;   // Set to maximize window (expanded to monitor)
    WINDOW_UNFOCUSED   :: 0x00000800;   // Set to window non focused
    WINDOW_TOPMOST     :: 0x00001000;   // Set to window always on top
    WINDOW_ALWAYS_RUN  :: 0x00000100;   // Set to allow windows running while minimized
    WINDOW_TRANSPARENT :: 0x00000010;   // Set to allow transparent framebuffer
    WINDOW_HIGHDPI     :: 0x00002000;   // Set to support HighDPI
    WINDOW_MOUSE_PASSTHROUGH :: 0x00004000; // Set to support mouse passthrough; only supported when FLAG_WINDOW_UNDECORATED
    BORDERLESS_WINDOWED_MODE :: 0x00008000; // Set to run program in borderless windowed mode
    MSAA_4X_HINT       :: 0x00000020;   // Set to try enabling MSAA 4X
    INTERLACED_HINT    :: 0x00010000;   // Set to try enabling interlaced video format (for V3D)
}

TraceLogLevel :: enum {
    ALL;            // Display all logs
    TRACE;          // Trace logging; intended for internal use only
    DEBUG;          // Debug logging; used for internal debugging; it should be disabled on release builds
    INFO;           // Info logging; used for program execution info
    WARNING;        // Warning logging; used on recoverable failures
    ERROR;          // Error logging; used on unrecoverable failures
    FATAL;          // Fatal logging; used to abort program: exit(EXIT_FAILURE)
    NONE;           // Disable logging
}

KeyboardKey :: enum {
    NULL            :: 0;        // Key: NULL; used for no key pressed
    // Alphanumeric keys
    APOSTROPHE      :: 39;       // Key: '
    COMMA           :: 44;       // Key: ;
    MINUS           :: 45;       // Key: -
    PERIOD          :: 46;       // Key: .
    SLASH           :: 47;       // Key: /
    ZERO            :: 48;       // Key: 0
    ONE             :: 49;       // Key: 1
    TWO             :: 50;       // Key: 2
    THREE           :: 51;       // Key: 3
    FOUR            :: 52;       // Key: 4
    FIVE            :: 53;       // Key: 5
    SIX             :: 54;       // Key: 6
    SEVEN           :: 55;       // Key: 7
    EIGHT           :: 56;       // Key: 8
    NINE            :: 57;       // Key: 9
    SEMICOLON       :: 59;       // Key: ;
    EQUAL           :: 61;       // Key: =
    A               :: 65;       // Key: A | a
    B               :: 66;       // Key: B | b
    C               :: 67;       // Key: C | c
    D               :: 68;       // Key: D | d
    E               :: 69;       // Key: E | e
    F               :: 70;       // Key: F | f
    G               :: 71;       // Key: G | g
    H               :: 72;       // Key: H | h
    I               :: 73;       // Key: I | i
    J               :: 74;       // Key: J | j
    K               :: 75;       // Key: K | k
    L               :: 76;       // Key: L | l
    M               :: 77;       // Key: M | m
    N               :: 78;       // Key: N | n
    O               :: 79;       // Key: O | o
    P               :: 80;       // Key: P | p
    Q               :: 81;       // Key: Q | q
    R               :: 82;       // Key: R | r
    S               :: 83;       // Key: S | s
    T               :: 84;       // Key: T | t
    U               :: 85;       // Key: U | u
    V               :: 86;       // Key: V | v
    W               :: 87;       // Key: W | w
    X               :: 88;       // Key: X | x
    Y               :: 89;       // Key: Y | y
    Z               :: 90;       // Key: Z | z
    LEFT_BRACKET    :: 91;       // Key: [
    BACKSLASH       :: 92;       // Key: '\'
    RIGHT_BRACKET   :: 93;       // Key: ]
    GRAVE           :: 96;       // Key: `
    // Function keys
    SPACE           :: 32;       // Key: Space
    ESCAPE          :: 256;      // Key: Esc
    ENTER           :: 257;      // Key: Enter
    TAB             :: 258;      // Key: Tab
    BACKSPACE       :: 259;      // Key: Backspace
    INSERT          :: 260;      // Key: Ins
    DELETE          :: 261;      // Key: Del
    RIGHT           :: 262;      // Key: Cursor right
    LEFT            :: 263;      // Key: Cursor left
    DOWN            :: 264;      // Key: Cursor down
    UP              :: 265;      // Key: Cursor up
    PAGE_UP         :: 266;      // Key: Page up
    PAGE_DOWN       :: 267;      // Key: Page down
    HOME            :: 268;      // Key: Home
    END             :: 269;      // Key: End
    CAPS_LOCK       :: 280;      // Key: Caps lock
    SCROLL_LOCK     :: 281;      // Key: Scroll down
    NUM_LOCK        :: 282;      // Key: Num lock
    PRINT_SCREEN    :: 283;      // Key: Print screen
    PAUSE           :: 284;      // Key: Pause
    F1              :: 290;      // Key: F1
    F2              :: 291;      // Key: F2
    F3              :: 292;      // Key: F3
    F4              :: 293;      // Key: F4
    F5              :: 294;      // Key: F5
    F6              :: 295;      // Key: F6
    F7              :: 296;      // Key: F7
    F8              :: 297;      // Key: F8
    F9              :: 298;      // Key: F9
    F10             :: 299;      // Key: F10
    F11             :: 300;      // Key: F11
    F12             :: 301;      // Key: F12
    LEFT_SHIFT      :: 340;      // Key: Shift left
    LEFT_CONTROL    :: 341;      // Key: Control left
    LEFT_ALT        :: 342;      // Key: Alt left
    LEFT_SUPER      :: 343;      // Key: Super left
    RIGHT_SHIFT     :: 344;      // Key: Shift right
    RIGHT_CONTROL   :: 345;      // Key: Control right
    RIGHT_ALT       :: 346;      // Key: Alt right
    RIGHT_SUPER     :: 347;      // Key: Super right
    KB_MENU         :: 348;      // Key: KB menu
    // Keypad keys
    KP_0            :: 320;      // Key: Keypad 0
    KP_1            :: 321;      // Key: Keypad 1
    KP_2            :: 322;      // Key: Keypad 2
    KP_3            :: 323;      // Key: Keypad 3
    KP_4            :: 324;      // Key: Keypad 4
    KP_5            :: 325;      // Key: Keypad 5
    KP_6            :: 326;      // Key: Keypad 6
    KP_7            :: 327;      // Key: Keypad 7
    KP_8            :: 328;      // Key: Keypad 8
    KP_9            :: 329;      // Key: Keypad 9
    KP_DECIMAL      :: 330;      // Key: Keypad .
    KP_DIVIDE       :: 331;      // Key: Keypad /
    KP_MULTIPLY     :: 332;      // Key: Keypad *
    KP_SUBTRACT     :: 333;      // Key: Keypad -
    KP_ADD          :: 334;      // Key: Keypad +
    KP_ENTER        :: 335;      // Key: Keypad Enter
    KP_EQUAL        :: 336;      // Key: Keypad =
    // Android key buttons
    BACK            :: 4;        // Key: Android back button
    MENU            :: 82;       // Key: Android menu button
    VOLUME_UP       :: 24;       // Key: Android volume up button
    VOLUME_DOWN     :: 25;        // Key: Android volume down button
}

MouseButton :: enum {
    LEFT    :: 0;       // Mouse button left
    RIGHT   :: 1;       // Mouse button right
    MIDDLE  :: 2;       // Mouse button middle (pressed wheel)
    SIDE    :: 3;       // Mouse button side (advanced mouse device)
    EXTRA   :: 4;       // Mouse button extra (advanced mouse device)
    FORWARD :: 5;       // Mouse button forward (advanced mouse device)
    BACK    :: 6;       // Mouse button back (advanced mouse device)
}

GamepadButton :: enum {
    UNKNOWN;             // Unknown button; just for error checking
    LEFT_FACE_UP;        // Gamepad left DPAD up button
    LEFT_FACE_RIGHT;     // Gamepad left DPAD right button
    LEFT_FACE_DOWN;      // Gamepad left DPAD down button
    LEFT_FACE_LEFT;      // Gamepad left DPAD left button
    RIGHT_FACE_UP;       // Gamepad right button up (i.e. PS3: Triangle; Xbox: Y)
    RIGHT_FACE_RIGHT;    // Gamepad right button right (i.e. PS3: Square; Xbox: X)
    RIGHT_FACE_DOWN;     // Gamepad right button down (i.e. PS3: Cross; Xbox: A)
    RIGHT_FACE_LEFT;     // Gamepad right button left (i.e. PS3: Circle; Xbox: B)
    LEFT_TRIGGER_1;      // Gamepad top/back trigger left (first); it could be a trailing button
    LEFT_TRIGGER_2;      // Gamepad top/back trigger left (second); it could be a trailing button
    RIGHT_TRIGGER_1;     // Gamepad top/back trigger right (one); it could be a trailing button
    RIGHT_TRIGGER_2;     // Gamepad top/back trigger right (second); it could be a trailing button
    MIDDLE_LEFT;         // Gamepad center buttons; left one (i.e. PS3: Select)
    MIDDLE;              // Gamepad center buttons; middle one (i.e. PS3: PS; Xbox: XBOX)
    MIDDLE_RIGHT;        // Gamepad center buttons; right one (i.e. PS3: Start)
    LEFT_THUMB;          // Gamepad joystick pressed button left
    RIGHT_THUMB;         // Gamepad joystick pressed button right
}

GamepadAxis :: enum {
    LEFT_X        :: 0;     // Gamepad left stick X axis
    LEFT_Y        :: 1;     // Gamepad left stick Y axis
    RIGHT_X       :: 2;     // Gamepad right stick X axis
    RIGHT_Y       :: 3;     // Gamepad right stick Y axis
    LEFT_TRIGGER  :: 4;     // Gamepad back trigger left, pressure level: [1..-1]
    RIGHT_TRIGGER :: 5;     // Gamepad back trigger right; pressure level: [1..-1]
}

MaterialMapIndex :: enum {
    ALBEDO;            // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
    METALNESS;         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
    NORMAL;            // Normal material
    ROUGHNESS;         // Roughness material
    OCCLUSION;         // Ambient occlusion material
    EMISSION;          // Emission material
    HEIGHT;            // Heightmap material
    CUBEMAP;           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    IRRADIANCE;        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    PREFILTER;         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    BRDF;              // Brdf material

    DIFFUSE :: ALBEDO;
    SPECULAR :: METALNESS;
}

ShaderLocationIndex :: enum {
    VERTEX_POSITION;     // Shader location: vertex attribute: position
    VERTEX_TEXCOORD01;   // Shader location: vertex attribute: texcoord01
    VERTEX_TEXCOORD02;   // Shader location: vertex attribute: texcoord02
    VERTEX_NORMAL;       // Shader location: vertex attribute: normal
    VERTEX_TANGENT;      // Shader location: vertex attribute: tangent
    VERTEX_COLOR;        // Shader location: vertex attribute: color
    MATRIX_MVP;          // Shader location: matrix uniform: model-view-projection
    MATRIX_VIEW;         // Shader location: matrix uniform: view (camera transform)
    MATRIX_PROJECTION;   // Shader location: matrix uniform: projection
    MATRIX_MODEL;        // Shader location: matrix uniform: model (transform)
    MATRIX_NORMAL;       // Shader location: matrix uniform: normal
    VECTOR_VIEW;         // Shader location: vector uniform: view
    COLOR_DIFFUSE;       // Shader location: vector uniform: diffuse color
    COLOR_SPECULAR;      // Shader location: vector uniform: specular color
    COLOR_AMBIENT;       // Shader location: vector uniform: ambient color
    MAP_ALBEDO;          // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
    MAP_METALNESS;       // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
    MAP_NORMAL;          // Shader location: sampler2d texture: normal
    MAP_ROUGHNESS;       // Shader location: sampler2d texture: roughness
    MAP_OCCLUSION;       // Shader location: sampler2d texture: occlusion
    MAP_EMISSION;        // Shader location: sampler2d texture: emission
    MAP_HEIGHT;          // Shader location: sampler2d texture: height
    MAP_CUBEMAP;         // Shader location: samplerCube texture: cubemap
    MAP_IRRADIANCE;      // Shader location: samplerCube texture: irradiance
    MAP_PREFILTER;       // Shader location: samplerCube texture: prefilter
    MAP_BRDF;            // Shader location: sampler2d texture: brdf

    MAP_DIFFUSE :: MAP_ALBEDO;
    MAP_SPECULAR :: MAP_METALNESS;
}

ShaderUniformDataType :: enum {
    FLOAT;           // Shader uniform type: float
    VEC2;            // Shader uniform type: vec2 (2 float)
    VEC3;            // Shader uniform type: vec3 (3 float)
    VEC4;            // Shader uniform type: vec4 (4 float)
    INT;             // Shader uniform type: int
    IVEC2;           // Shader uniform type: ivec2 (2 int)
    IVEC3;           // Shader uniform type: ivec3 (3 int)
    IVEC4;           // Shader uniform type: ivec4 (4 int)
    SAMPLER2D;       // Shader uniform type: sampler2d
}

ShaderAttributeDataType :: enum {
    FLOAT;
    VEC2;
    VEC3;
    VEC4;
}

PixelFormat :: enum {
    UNCOMPRESSED_GRAYSCALE :: 1; // 8 bit per pixel (no alpha)
    UNCOMPRESSED_GRAY_ALPHA;    // 8*2 bpp (2 channels)
    UNCOMPRESSED_R5G6B5;        // 16 bpp
    UNCOMPRESSED_R8G8B8;        // 24 bpp
    UNCOMPRESSED_R5G5B5A1;      // 16 bpp (1 bit alpha)
    UNCOMPRESSED_R4G4B4A4;      // 16 bpp (4 bit alpha)
    UNCOMPRESSED_R8G8B8A8;      // 32 bpp
    UNCOMPRESSED_R32;           // 32 bpp (1 channel - float)
    UNCOMPRESSED_R32G32B32;     // 32*3 bpp (3 channels - float)
    UNCOMPRESSED_R32G32B32A32;  // 32*4 bpp (4 channels - float)
    UNCOMPRESSED_R16;           // 16 bpp (1 channel - half float)
    UNCOMPRESSED_R16G16B16;     // 16*3 bpp (3 channels - half float)
    UNCOMPRESSED_R16G16B16A16;  // 16*4 bpp (4 channels - half float)
    COMPRESSED_DXT1_RGB;        // 4 bpp (no alpha)
    COMPRESSED_DXT1_RGBA;       // 4 bpp (1 bit alpha)
    COMPRESSED_DXT3_RGBA;       // 8 bpp
    COMPRESSED_DXT5_RGBA;       // 8 bpp
    COMPRESSED_ETC1_RGB;        // 4 bpp
    COMPRESSED_ETC2_RGB;        // 4 bpp
    COMPRESSED_ETC2_EAC_RGBA;   // 8 bpp
    COMPRESSED_PVRT_RGB;        // 4 bpp
    COMPRESSED_PVRT_RGBA;       // 4 bpp
    COMPRESSED_ASTC_4x4_RGBA;   // 8 bpp
    COMPRESSED_ASTC_8x8_RGBA;   // 2 bpp
}

TextureFilter :: enum {
    POINT;
    BILINEAR;
    TRILINEAR;
    ANISOTROPIC_4X;
    ANISOTROPIC_8X;
    ANISOTROPIC_16X;
}

TextureWrap :: enum {
    REPEAT;
    CLAMP;
    MIRROR_REPEAT;
    MIRROR_CLAMP;
}

CubemapLayout :: enum {
    AUTO_DETECT;             // Automatically detect layout type
    LINE_VERTICAL;           // Layout is defined by a vertical line with faces
    LINE_HORIZONTAL;         // Layout is defined by a horizontal line with faces
    CROSS_THREE_BY_FOUR;     // Layout is defined by a 3x4 cross with cubemap faces
    CROSS_FOUR_BY_THREE;     // Layout is defined by a 4x3 cross with cubemap faces
    PANORAMA;                // Layout is defined by a panorama image (equirrectangular map)
}

FontType :: enum {
    DEFAULT;
    BITMAP;
    SDF;
}

BlendMode :: enum {
    ALPHA;                    // Blend textures considering alpha (default)
    ADDITIVE;                 // Blend textures adding colors
    MULTIPLIED;               // Blend textures multiplying colors
    ADD_COLORS;               // Blend textures adding colors (alternative)
    SUBTRACT_COLORS;          // Blend textures subtracting colors (alternative)
    ALPHA_PREMULTIPLY;        // Blend premultiplied textures considering alpha
    CUSTOM;                   // Blend textures using custom src/dst factors (use rlSetBlendFactors())
    CUSTOM_SEPARATE;          // Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())
}

Gesture :: enum {
    NONE        :: 0;        // No gesture
    TAP         :: 1;        // Tap gesture
    DOUBLETAP   :: 2;        // Double tap gesture
    HOLD        :: 4;        // Hold gesture
    DRAG        :: 8;        // Drag gesture
    SWIPE_RIGHT :: 16;       // Swipe right gesture
    SWIPE_LEFT  :: 32;       // Swipe left gesture
    SWIPE_UP    :: 64;       // Swipe up gesture
    SWIPE_DOWN  :: 128;      // Swipe down gesture
    PINCH_IN    :: 256;      // Pinch in gesture
    PINCH_OUT   :: 512;      // Pinch out gesture
}

CameraMode :: enum {
    CUSTOM;
    FREE;
    ORBITAL;
    FIRST_PERSON;
    THIRD_PERSON;
}

CameraProjection :: enum {
    PERSPECTIVE;
    ORTHOGRAPHIC;
}

NPatchLayout :: enum {
    NINE_PATCH;
    THREE_PATCH_VERTICAL;
    THREE_PATCH_HORIZONTAL;
}



